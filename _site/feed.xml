<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-02-24T22:21:33+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">YEWPO’s Blog</title><subtitle>Study notes about CS</subtitle><entry><title type="html">数字IC设计</title><link href="http://localhost:4000/cpu/2024/02/21/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1.html" rel="alternate" type="text/html" title="数字IC设计" /><published>2024-02-21T21:38:00+08:00</published><updated>2024-02-21T21:38:00+08:00</updated><id>http://localhost:4000/cpu/2024/02/21/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1</id><content type="html" xml:base="http://localhost:4000/cpu/2024/02/21/%E6%95%B0%E5%AD%97IC%E8%AE%BE%E8%AE%A1.html"><![CDATA[<p><strong>同步电路和异步电路的区别</strong></p>

<p>是否与时钟有固定的因果关系。</p>

<p><strong>什么是亚稳态</strong></p>

<p>亚稳态是指触发器无法在某个规定的时间段内到达一个可以确定的状态。</p>

<p>使用两级触发器可以防止亚稳态传播到电路中。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/2%20dff.jpg" alt="2 dff" /></p>

<p><strong>系统最高计算速度</strong></p>

<p>最小时钟周期=触发器输出时间+组合逻辑时延+D触发器建立时间</p>

<p>时钟频率=最小时钟周期的倒数</p>

<p><strong>对于多位的异步信号如何进行同步</strong></p>

<ul>
  <li>采用保持寄存器加握手信号的方法</li>
  <li>异步FIFO</li>
</ul>

<p><strong>锁存器和触发器的区别</strong></p>

<p>电平敏感的存储器件称为锁存器。</p>

<p>有交叉耦合的们构成的双稳态的存储器件称为触发器。</p>

<p><strong>什么是竞争和冒险现象</strong></p>

<p>在组合电路中，某一输入变量经过不同途径传输后，到达电路中某一汇合点的时间有先有后，这种现象称竞争；由于竞争而使电路输出发生瞬时错误的现象叫做冒险。（也就是由于竞争产生的毛刺叫做冒险）。</p>

<p>判断方法：</p>

<ul>
  <li>代数法：布尔式中有相反的信号</li>
  <li>卡诺图：卡诺圈相切</li>
  <li>实验法：滤波器观察</li>
</ul>

<p>解决方法：</p>

<ul>
  <li>加滤波电容</li>
  <li>加选通信号</li>
  <li>增加冗余项消除逻辑冒险</li>
</ul>

<p><strong>同步复位与异步复位的区别</strong></p>

<p>同步复位在时钟沿发生变化时，完成复位。</p>

<p>异步复位只需要复位信号满足条件就完成复位，要求较高，容易产生毛刺。</p>

<p><strong>摩尔状态机和米利状态机的区别</strong></p>

<p>摩尔状态机：状态输出只跟当前状态有关。</p>

<p>米利状态机：状态输出既和当前状态有关也和当前输入有关。</p>

<p><strong>多时钟域设计中，如何处理信号跨时钟域</strong></p>

<p>进行同步处理。单个信号使用两级触发器来同步；数据或者地址总线跨时钟域可以用异步FIFO；也可以使用握手信号。</p>

<p><strong>SRAM, FLASH, DRAM, SSRAM, SDRAM的区别</strong></p>

<ul>
  <li>SRAM：静态随机存储器，存储速度快，容量小，掉电数据丢失。常用于缓存。</li>
  <li>FLASH：闪存，存取速度慢，容量大，掉电数据不丢失。</li>
  <li>DRAM：动态随机存储器。必须不断刷新。访问速度快，能耗大，常用作内存。</li>
  <li>SSRAM：同步静态随机存储器，时钟相关。</li>
  <li>SDRAM：同步动态随机存储器，时钟相关。</li>
</ul>

<p><strong>四种复用方式</strong></p>

<ul>
  <li>频分</li>
  <li>时分</li>
  <li>码分</li>
  <li>波分</li>
</ul>

<p><strong>名词解析</strong></p>

<ul>
  <li>CMOS：互补金属氧化物半导体</li>
  <li>MCU：微控制单元</li>
  <li>DSP：数字信号处理器</li>
  <li>FPGA：现场可编程门阵列，它是在PAL、GAL、CPLD等可编程器件的基础上进一步发展的产物。</li>
  <li>ASIC：专用集成电路</li>
  <li>PCI：外围组件互联总线标准</li>
</ul>

<p><strong>集成电路设计流程</strong></p>

<ol>
  <li>
    <p>需求分析。分析用户或市场的需求，并将其翻译成对芯片产品的技术需求。</p>
  </li>
  <li>
    <p>算法设计。设计和优化芯片钟所使用的算法。这一阶段一般使用高级编程语言（如C/C++），利用算法级建模和仿真工具（如MATLAB，SPW）进行浮点和定点的仿真，进而对算法进行评估和优化。</p>
  </li>
  <li>
    <p>构架设计。根据设计的功能需求和算法分析的结果，设计芯片的构架，并对不同的方案进行比较，选择性能价格最优的方案。</p>
  </li>
  <li>
    <p>RTL设计（代码输入）。使用HDL语言完成对设计实体的RTL级描述。</p>
  </li>
  <li>
    <p>RTL验证（功能仿真）。使用仿真工具或其他RTL代码分析工具，验证RTL代码的质量和性能。</p>
  </li>
  <li>
    <p>综合。从RTL代码生成描述实际电路的门级网表文件。</p>
  </li>
  <li>
    <p>门级验证（综合后仿真）。对综合产生的门级网表进行验证。这一阶段通常会使用仿真、静态时序分析和形式验证等工具。</p>
  </li>
  <li>
    <p>布局布线。后端设计对综合产生的门级网表进行布局规划（Floorplanning）、布局（Placement）、布线（Routing），生成生产用的版图。</p>
  </li>
  <li>
    <p>电路参数提取确定芯片中互连线的寄生参数，从而获得门级的延时信息。</p>
  </li>
  <li>
    <p>版图后验证。根据后端设计后取得的新的延时信息，再次验证设计是否能够实现所有的功能和性能指标。</p>
  </li>
  <li>
    <p>芯片生产。生产在特定的芯片工艺线上制造出芯片。</p>
  </li>
  <li>
    <p>芯片测试。对制造好的芯片进行测试，检测生产中产生的缺陷和问题。</p>
  </li>
</ol>]]></content><author><name></name></author><category term="CPU" /><summary type="html"><![CDATA[同步电路和异步电路的区别]]></summary></entry><entry><title type="html">rCore的内存管理</title><link href="http://localhost:4000/rcore/2024/02/21/rCore%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" rel="alternate" type="text/html" title="rCore的内存管理" /><published>2024-02-21T21:38:00+08:00</published><updated>2024-02-21T21:38:00+08:00</updated><id>http://localhost:4000/rcore/2024/02/21/rCore%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86</id><content type="html" xml:base="http://localhost:4000/rcore/2024/02/21/rCore%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"><![CDATA[<blockquote>
  <p>先来一点<code class="language-plaintext highlighter-rouge">rust</code>相关。</p>

  <p><strong><code class="language-plaintext highlighter-rouge">ref</code>关键字</strong></p>

  <p>赋值语句中左边的<code class="language-plaintext highlighter-rouge">ref</code>关键字等价于右边的<code class="language-plaintext highlighter-rouge">&amp;</code>符号。</p>

  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'Q'</span><span class="p">;</span>
<span class="k">let</span> <span class="k">ref</span> <span class="n">ref_c1</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="k">let</span> <span class="n">ref_c2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">;</span>
</code></pre></div>  </div>

  <p>再和<code class="language-plaintext highlighter-rouge">mut</code>结合变成可引用变量。</p>

  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">let</span> <span class="k">ref</span> <span class="k">mut</span> <span class="n">ref_c1</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
<span class="o">*</span><span class="n">c</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div>  </div>

  <p><strong><code class="language-plaintext highlighter-rouge">iter()</code>vs<code class="language-plaintext highlighter-rouge">iter_mut()</code>vs<code class="language-plaintext highlighter-rouge">into_iter()</code></strong></p>

  <ul>
    <li><code class="language-plaintext highlighter-rouge">iter()</code>：借用迭代器。</li>
    <li><code class="language-plaintext highlighter-rouge">iter_mut()</code>：借用可变迭代器。</li>
    <li><code class="language-plaintext highlighter-rouge">into_iter()</code>：获取迭代器。</li>
  </ul>

  <p><strong><code class="language-plaintext highlighter-rouge">rust</code>智能指针/容器以及其他类型的内存布局</strong></p>

  <p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20240223191657122.png" alt="image-20240223191657122" /></p>

  <p><strong><code class="language-plaintext highlighter-rouge">rust</code>格式化字符串</strong></p>

  <p>使用<code class="language-plaintext highlighter-rouge">{:?}</code>和<code class="language-plaintext highlighter-rouge">{:#?}</code>进行优美地输出，前者是行输出，后者是列输出。</p>

  <p>字符串填充方法如下（默认左对齐）：</p>

  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">//-----------------------------------</span>
    <span class="c1">// 以下全部输出 "Hello x    !"</span>
    <span class="c1">// 为"x"后面填充空格，补齐宽度5</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:5}!"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">);</span>
    <span class="c1">// 使用参数5来指定宽度</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:1$}!"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="c1">// 使用x作为占位符输出内容，同时使用5作为宽度</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {1:0$}!"</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="s">"x"</span><span class="p">);</span>
    <span class="c1">// 使用有名称的参数作为宽度</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:width$}!"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">,</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">5</span><span class="p">);</span>
    <span class="c1">//-----------------------------------</span>

    <span class="c1">// 使用参数5为参数x指定宽度，同时在结尾输出参数5 =&gt; Hello x    !5</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:1$}!{}"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <p>数字填充方法如下（默认右对齐）：</p>

  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 宽度是5 =&gt; Hello     5!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:5}!"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="c1">// 显式的输出正号 =&gt; Hello +5!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:+}!"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="c1">// 宽度5，使用0进行填充 =&gt; Hello 00005!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:05}!"</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="c1">// 负号也要占用一位宽度 =&gt; Hello -0005!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:05}!"</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <p>对齐方法如下：</p>

  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 以下全部都会补齐5个字符的长度</span>
    <span class="c1">// 左对齐 =&gt; Hello x    !</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:&lt;5}!"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">);</span>
    <span class="c1">// 右对齐 =&gt; Hello     x!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:&gt;5}!"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">);</span>
    <span class="c1">// 居中对齐 =&gt; Hello   x  !</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:^5}!"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">);</span>

    <span class="c1">// 对齐并使用指定符号填充 =&gt; Hello x&amp;&amp;&amp;&amp;!</span>
    <span class="c1">// 指定符号填充的前提条件是必须有对齐字符</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Hello {:&amp;&lt;5}!"</span><span class="p">,</span> <span class="s">"x"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <p>进制方法如下：</p>

  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 二进制 =&gt; 0b11011!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:#b}!"</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
    <span class="c1">// 八进制 =&gt; 0o33!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:#o}!"</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
    <span class="c1">// 十进制 =&gt; 27!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}!"</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
    <span class="c1">// 小写十六进制 =&gt; 0x1b!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:#x}!"</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
    <span class="c1">// 大写十六进制 =&gt; 0x1B!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:#X}!"</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>

    <span class="c1">// 不带前缀的十六进制 =&gt; 1b!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:x}!"</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>

    <span class="c1">// 使用0填充二进制，宽度为10 =&gt; 0b00011011!</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:#010b}!"</span><span class="p">,</span> <span class="mi">27</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>  </div>

  <p><strong><code class="language-plaintext highlighter-rouge">rust</code>操作符重载</strong></p>

  <p>假设我们有一个结构体为<code class="language-plaintext highlighter-rouge">Foo</code>，内部有一个变量称之为<code class="language-plaintext highlighter-rouge">val: usize</code>。正常情况下我们不可以对<code class="language-plaintext highlighter-rouge">Foo</code>进行加一操作，但是我们可以使用<code class="language-plaintext highlighter-rouge">core::ops</code>对加号进行重载。具体的实现方法如下：</p>

  <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span>
  	<span class="n">val</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nn">ops</span><span class="p">::</span><span class="nb">Add</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Foo</span> <span class="p">{</span>
  <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="k">Self</span><span class="p">;</span>
  
  <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
    <span class="k">Self</span> <span class="p">{</span> <span class="k">self</span><span class="py">.val</span> <span class="o">+</span> <span class="n">rhs</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>  </div>
</blockquote>

<h2 id="堆分配">堆分配</h2>

<p>使用了<code class="language-plaintext highlighter-rouge">rCore</code>自己实现的<code class="language-plaintext highlighter-rouge">buddy_system_allocator</code>来管理堆空间。使用<a href="https://github.com/rcore-os/buddy_system_allocator">伙伴系统</a>算法实现，后期可以学习一下源码。这里先直接使用了。当使用<code class="language-plaintext highlighter-rouge">rust</code>的只能指针/容器的时候，会自动调用这些堆分配的方法，不用向<code class="language-plaintext highlighter-rouge">C</code>语言的<code class="language-plaintext highlighter-rouge">malloc</code>以及<code class="language-plaintext highlighter-rouge">free</code>函数显式分配。</p>

<h2 id="帧分配">帧分配</h2>

<p><code class="language-plaintext highlighter-rouge">rCore</code>内存管理的关键部分了，方式是维护一个可用内存的空间范围，加上一个回收空间列表。相比之下，<code class="language-plaintext highlighter-rouge">xv6</code>直接维护的是一个空闲空间链表，做法会暴力一些。</p>

<p><code class="language-plaintext highlighter-rouge">rCore</code>分配空间的方式是，尽量从回收列表中拿取空间，不能满足的时候，调整可用内存空间的范围，分配一个空闲空间。大多数情况下，请求分配都是小空间，基本能从回收列表中满足。这样实现，不仅分配空间开销小，也不像<code class="language-plaintext highlighter-rouge">xv6</code>需要占用大量固定的内存空间。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/rcore%20frame%20allocator.jpg" alt="rcore frame allocator" /></p>

<p><code class="language-plaintext highlighter-rouge">rCore</code>没有限制<code class="language-plaintext highlighter-rouge">Allocator</code>的算法实现方式，任何实现了<code class="language-plaintext highlighter-rouge">allocator</code>接口的分配器都可以被<code class="language-plaintext highlighter-rouge">rCore</code>使用，利用了面向对象编程的思想。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/sfa%20cls.jpg" alt="sfa cls" /></p>

<h2 id="memoryset"><code class="language-plaintext highlighter-rouge">MemorySet</code></h2>

<blockquote>
  <p>在学习<code class="language-plaintext highlighter-rouge">MemorySet</code>之前，先看看<code class="language-plaintext highlighter-rouge">rust</code>如何自己创建迭代器。（因为<code class="language-plaintext highlighter-rouge">VPNRange</code>用到了）</p>

  <ol>
    <li>首先，需要声明一个迭代器信息的结构体，记录当前迭代的位置以及结束的位置。为这个结构体实现迭代器的<code class="language-plaintext highlighter-rouge">next</code>方法。</li>
    <li>为原来的结构体容器实现一个<code class="language-plaintext highlighter-rouge">IntoIterator</code>的方法，将其转换为一个迭代器。</li>
  </ol>

  <p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/rustiter.jpg" alt="rustiter" /></p>
</blockquote>

<h2 id="参考资料">参考资料</h2>

<p><a href="https://rcore-os.cn/rCore-Tutorial-Book-v3/chapter4/index.html"><code class="language-plaintext highlighter-rouge">rCore</code>地址空间</a></p>

<p><a href="https://course.rs/basic/formatted-output.html">Rust语言圣经</a></p>

<p><a href="https://doc.rust-lang.org/rust-by-example/trait/ops.html">Rust操作符重载</a></p>]]></content><author><name></name></author><category term="rCore" /><summary type="html"><![CDATA[先来一点rust相关。 ref关键字 赋值语句中左边的ref关键字等价于右边的&amp;符号。 let c = 'Q'; let ref ref_c1 = c; let ref_c2 = &amp;c; 再和mut结合变成可引用变量。 let c = 1; let ref mut ref_c1 = c; *c = 2; iter()vsiter_mut()vsinto_iter() iter()：借用迭代器。 iter_mut()：借用可变迭代器。 into_iter()：获取迭代器。 rust智能指针/容器以及其他类型的内存布局 rust格式化字符串 使用{:?}和{:#?}进行优美地输出，前者是行输出，后者是列输出。 字符串填充方法如下（默认左对齐）： fn main() { //----------------------------------- // 以下全部输出 "Hello x !" // 为"x"后面填充空格，补齐宽度5 println!("Hello {:5}!", "x"); // 使用参数5来指定宽度 println!("Hello {:1$}!", "x", 5); // 使用x作为占位符输出内容，同时使用5作为宽度 println!("Hello {1:0$}!", 5, "x"); // 使用有名称的参数作为宽度 println!("Hello {:width$}!", "x", width = 5); //----------------------------------- // 使用参数5为参数x指定宽度，同时在结尾输出参数5 =&gt; Hello x !5 println!("Hello {:1$}!{}", "x", 5); } 数字填充方法如下（默认右对齐）： fn main() { // 宽度是5 =&gt; Hello 5! println!("Hello {:5}!", 5); // 显式的输出正号 =&gt; Hello +5! println!("Hello {:+}!", 5); // 宽度5，使用0进行填充 =&gt; Hello 00005! println!("Hello {:05}!", 5); // 负号也要占用一位宽度 =&gt; Hello -0005! println!("Hello {:05}!", -5); } 对齐方法如下： fn main() { // 以下全部都会补齐5个字符的长度 // 左对齐 =&gt; Hello x ! println!("Hello {:&lt;5}!", "x"); // 右对齐 =&gt; Hello x! println!("Hello {:&gt;5}!", "x"); // 居中对齐 =&gt; Hello x ! println!("Hello {:^5}!", "x"); // 对齐并使用指定符号填充 =&gt; Hello x&amp;&amp;&amp;&amp;! // 指定符号填充的前提条件是必须有对齐字符 println!("Hello {:&amp;&lt;5}!", "x"); } 进制方法如下： fn main() { // 二进制 =&gt; 0b11011! println!("{:#b}!", 27); // 八进制 =&gt; 0o33! println!("{:#o}!", 27); // 十进制 =&gt; 27! println!("{}!", 27); // 小写十六进制 =&gt; 0x1b! println!("{:#x}!", 27); // 大写十六进制 =&gt; 0x1B! println!("{:#X}!", 27); // 不带前缀的十六进制 =&gt; 1b! println!("{:x}!", 27); // 使用0填充二进制，宽度为10 =&gt; 0b00011011! println!("{:#010b}!", 27); } rust操作符重载 假设我们有一个结构体为Foo，内部有一个变量称之为val: usize。正常情况下我们不可以对Foo进行加一操作，但是我们可以使用core::ops对加号进行重载。具体的实现方法如下： struct Foo { val: usize, } impl ops::Add&lt;usize&gt; for Foo { type Output = Self; fn add(self, rhs: usize) -&gt; Self { Self { self.val + rhs } } }]]></summary></entry><entry><title type="html">Lab xv6 and Unix utils</title><link href="http://localhost:4000/xv6/2024/02/20/lab-xv6-and-utils.html" rel="alternate" type="text/html" title="Lab xv6 and Unix utils" /><published>2024-02-20T18:40:00+08:00</published><updated>2024-02-20T18:40:00+08:00</updated><id>http://localhost:4000/xv6/2024/02/20/lab-xv6-and-utils</id><content type="html" xml:base="http://localhost:4000/xv6/2024/02/20/lab-xv6-and-utils.html"><![CDATA[<h2 id="1-boot-xv6">1 Boot xv6</h2>

<p>导入实验和启动系统</p>

<pre><code class="language-git">git clone git://g.csail.mit.edu/xv6-labs-2022
cd xv6-labs-2022
git cheakout util
git commit -am 'my solution for util lab exercise 1'
make qemu
</code></pre>

<p>测试自己的代码的正确性</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make grade <span class="c">#for all test</span>
make <span class="nv">GRADEFLAGS</span><span class="o">=</span><span class="s1">'test'</span> grade <span class="c"># test just for test</span>
</code></pre></div></div>

<p>或者</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.<span class="se">\g</span>rade-lab-util &lt;<span class="nb">test </span>name&gt;
</code></pre></div></div>

<h2 id="2-sleepeasy">2 sleep(easy)</h2>

<blockquote>
  <p>实现一个sleep程序，可以暂停用户要求的时间。</p>
</blockquote>

<h3 id="21-系统调用sleep">2.1 系统调用sleep</h3>

<p>本实验只用实现系统调用。</p>

<h3 id="22-程序代码">2.2 程序代码</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"kernel/types.h"</span><span class="cp">
#include</span> <span class="cpf">"kernel/stat.h"</span><span class="cp">
#include</span> <span class="cpf">"user/user.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"Usage: sleep time</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">'0'</span> <span class="o">||</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">'9'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"Usage: sleep time</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">sleep</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]));</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="3-pingpongeasy">3 pingpong(easy)</h2>

<blockquote>
  <p>实现一个程序，完成两个进程之间一个字节的信息交流。</p>

  <p>实现方法：通过管道</p>

  <p>父进程向子进程通过管道发送一个字节的信息后，子进程接受到消息后打印接受消息信息，并向父进程发送一个字节的信息，父进程收到消息之后，打印接受到消息的信息。</p>
</blockquote>

<h3 id="31-系统调用pipereadwritegetpidfork">3.1 系统调用pipe，read，write，getpid，fork</h3>

<p><strong>对于子进程和父进程，他们共享文件描述符，但是相互独立。</strong></p>

<h4 id="311-pipe">3.1.1 pipe</h4>

<p>管道是一个小型的系统缓存，并向进程提供两个文件描述符，一个管道读取描述符一个管道写入描述符。用户只能在管道的一端写入，并在另一端读取。管道以这种方式向进程提供了信息交流的方式。</p>

<p>管道具有以下特点：</p>

<ul>
  <li>半双工</li>
  <li>不可重复读取</li>
</ul>

<p>基于以上特性，<strong>数据在管道中只能单向传输，而且不能长期存在（读取后就不存在了）。</strong></p>

<h4 id="312-获取一个pipe">3.1.2 获取一个pipe</h4>

<p>通过系统调用<code class="language-plaintext highlighter-rouge">pipe</code>函数，可以申请得到一个pipe。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</code></pre></div></div>

<p>如果申请成功，pipe[0]储存的读取描述符，而p[1]储存的是写入描述符。</p>

<h4 id="313-fork">3.1.3 fork</h4>

<p><code class="language-plaintext highlighter-rouge">fork</code>的作用是创建一个子进程，在父进程中返回子进程的<code class="language-plaintext highlighter-rouge">pid</code>，而在子进程中返回0；</p>

<p>有关fork的详细细节，可以参考<code class="language-plaintext highlighter-rouge">CSAPP3E</code>的8.4节。</p>

<p><strong>由于父子进程共享文件描述符，所以子进程和父进程都需要手动关闭相关的文件描述符</strong></p>

<h4 id="314-read--write">3.1.4 read &amp; write</h4>

<p>详细内容可以参考<code class="language-plaintext highlighter-rouge">CSAPP3E</code>第10章。</p>

<h4 id="315-getpid">3.1.5 getpid</h4>

<p>获得当前进程的pid。</p>

<h4 id="32-代码实现">3.2 代码实现</h4>

<p>在父进程创建管道，之后会与子进程共享。</p>

<p>由于子进程和父进程几乎并行，所以我们要先等待子进程结束后再继续执行父进程。（否则子进程的管道就没有读的了，要发生阻塞直到对应的文件描述符关闭，而且没有相应的收到信息的输出）</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"kernel/types.h"</span><span class="cp">
#include</span> <span class="cpf">"kernel/stat.h"</span><span class="cp">
#include</span> <span class="cpf">"user/user.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"Usage: pingpong</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

    <span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">read</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

        <span class="n">fprintf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"%d: received ping</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

        <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

        <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="n">read</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">fprintf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"%d: received pong</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>

    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="4-primeshard">4 primes(hard)</h2>

<blockquote>
  <p>阅读 <code class="language-plaintext highlighter-rouge">Bell Lab and CSP Thread</code>材料，用进程间的通信完成材料中质数筛选的实验</p>

  <p>该程序的思路的流程图;</p>

  <p><img src="D:\assignment\glimmer\notes\6.S081 OS Labs\image-20221018214030001.png" alt="image-20221018214030001" /></p>

  <p>向每个质数分配一个子进程，用pipe管道向下一个子进程传输不是自己的倍数的数。</p>
</blockquote>

<h3 id="41-写入管道阻塞">4.1 写入管道阻塞</h3>

<h4 id="411-产生原因">4.1.1 产生原因</h4>

<p>因为管道提供的缓存大小有限（很小），当输入到管道中的数据的大小达到管道的最大的容量的时候，写入就会阻塞。</p>

<h4 id="412-解决方案">4.1.2 解决方案</h4>

<p>为了解决这个问题，需要先创建子进程开始从管道中读取，父进程在此之后提供输入。</p>

<h4 id="413-新的问题">4.1.3 新的问题</h4>

<p>由于每个进程都要先创建子进程，所以进程会一直创建下去，然后就崩溃了，0.0</p>

<h3 id="42-无限子进程">4.2 无限子进程</h3>

<h4 id="421-产生原因">4.2.1 产生原因</h4>

<p>见4.1.3</p>

<h4 id="422-解决方法">4.2.2 解决方法</h4>

<ul>
  <li>能否提供一个标记值？</li>
</ul>

<p>该方法的问题：父进程创建一个子进程的时候，子进程会复制父进程的变量的副本（子进程是父进程的复制品），然而父进程一开始就会创建子进程，即使后面父进程的检查发现了问题打上了这个标记，子进程也不知道，因为变量之间相互独立。</p>

<ul>
  <li>无奈本题特殊解（我太菜了）</li>
</ul>

<p>由于是筛质数，所以进程数有限，当进程数超过要判断的数的总数之后，就可以不用在产生新的进程了。（特殊解罢了，一旦要判断数的总数增加，这个程序产生的无用的进程就更多了，。。）</p>

<h3 id="43-创建进程">4.3 创建进程</h3>

<p>由于子进程很多，不太可能写条件嵌套吧？</p>

<p><strong>用递归函数来创建子子进程</strong></p>

<p>形如：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">forkandfork</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">forkandfork</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="44-进程间的沟通">4.4 进程间的沟通</h3>

<p>进程间的沟通参考<code class="language-plaintext highlighter-rouge">3 pingpong</code></p>

<p><strong>实现</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prime</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prime</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"prime %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">prime</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">%</span> <span class="n">prime</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">value</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="45-代码实现">4.5 代码实现</h3>

<pre><code class="language-C">#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"

int p[2];
int flag = 1;
int count = 0;
int num = 35;

void forkPrime() {
    count++;

    if (count &gt; num) {
        close(p[0]);
        close(1);
        exit(0);
    }


    int fd0 = p[0];

    pipe(p);

    if (fork() == 0) {
        close(fd0);
        close(p[1]);
        
        forkPrime();
    }

    close(p[0]);

    int prime = 0;
    int value = 0;

    while (read(fd0, &amp;value, 32)) {
        if (!prime) {
            prime = value;
            fprintf(1, "prime %d\n", prime);
        }

        if (value % prime != 0) {
            write(p[1], &amp;value, 32);
        }
    }

    close(fd0);
    close(p[1]);
    close(1);

    wait(0);

    exit(0);
}

int main(int argc, char *argv[]) {
    close(0);
    close(2);

    pipe(p);

    if (fork() == 0) {
        close(p[1]);
        forkPrime();
    }

    close(p[0]);

    for (int i = 2; i &lt;= num; ++i) {
        write(p[1], &amp;i, 32);
    }

    close(p[1]);
    close(1);

    wait(0);

    exit(0);
}
</code></pre>

<h2 id="5-findmoderate">5 find(moderate)</h2>

<blockquote>
  <p>编写一个程序，实现在指定文件夹以及子文件夹中搜索要查找到的文件。</p>
</blockquote>

<h3 id="51-阅读lsc">5.1 阅读ls.c</h3>

<p>ls.c 源码</p>

<pre><code class="language-C">#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

char*
fmtname(char *path)
{
  static char buf[DIRSIZ+1];
  char *p;

  // Find first character after last slash.
  for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--)
    ;
  p++;

  // Return blank-padded name.
  if(strlen(p) &gt;= DIRSIZ)
    return p;
  memmove(buf, p, strlen(p));
  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
  return buf;
}

void
ls(char *path)
{
  char buf[512], *p;
  int fd;
  struct dirent de;
  struct stat st;

  if((fd = open(path, 0)) &lt; 0){
    fprintf(2, "ls: cannot open %s\n", path);
    return;
  }

  if(fstat(fd, &amp;st) &lt; 0){
    fprintf(2, "ls: cannot stat %s\n", path);
    close(fd);
    return;
  }

  switch(st.type){
  case T_FILE:
    printf("%s %d %d %l\n", fmtname(path), st.type, st.ino, st.size);
    break;

  case T_DIR:
    if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf){
      printf("ls: path too long\n");
      break;
    }
    strcpy(buf, path);
    p = buf+strlen(buf);
    *p++ = '/';
    while(read(fd, &amp;de, sizeof(de)) == sizeof(de)){
      if(de.inum == 0)
        continue;
      memmove(p, de.name, DIRSIZ);
      p[DIRSIZ] = 0;
      if(stat(buf, &amp;st) &lt; 0){
        printf("ls: cannot stat %s\n", buf);
        continue;
      }
      printf("%s %d %d %d\n", fmtname(buf), st.type, st.ino, st.size);
    }
    break;
  }
  close(fd);
}

int
main(int argc, char *argv[])
{
  int i;

  if(argc &lt; 2){
    ls(".");
    exit(0);
  }
  for(i=1; i&lt;argc; i++)
    ls(argv[i]);
  exit(0);
}

</code></pre>

<h4 id="511-fmtname函数">5.1.1 fmtname函数</h4>

<p>该函数的作用是：提取路径中的文件名。</p>

<p>对于<code class="language-plaintext highlighter-rouge">memset(buf + strlen(p), ' ', DIRSIZ - strlen(p))</code>的理解，此处用<code class="language-plaintext highlighter-rouge">‘ ’</code>对末尾数组的初始化并不是错误的，这样初始化的目的是为了ls在打印的时候列对齐。（不知道这个目的的意义有多大。。。</p>

<h4 id="512-ls-函数">5.1.2 ls 函数</h4>

<p>很明显，该函数的目的就是打印当前目录下的内容</p>

<h5 id="5121-目录类型">5.1.2.1 目录类型</h5>

<p>按照xv6的参考文档，目录可以分成三种类型：</p>

<ul>
  <li>文件</li>
  <li>设备文件</li>
  <li>目录</li>
</ul>

<p>三种形式都可以打开，并且我们可以用<code class="language-plaintext highlighter-rouge">fstat</code>函数获得该目录的信息。信息储存在<code class="language-plaintext highlighter-rouge">struct stat</code>中。该结构体的<code class="language-plaintext highlighter-rouge">type</code>属性表示了该目录的类型：</p>

<ul>
  <li>T_FILE 文件类型</li>
  <li>T_DEVICE 设备文件类型</li>
  <li>T_DIR 目录类型</li>
</ul>

<h5 id="5122-实现的思路">5.1.2.2 实现的思路</h5>

<p>打开该目录，保存对应的文件描述符。并用<code class="language-plaintext highlighter-rouge">fstat</code>获得该文件描述符中的信息。如果该目录的类型是文件，或者是设备文件，就直接打印文件名。如果该目录类型是目录，则该文件里描述了该目录中的文件信息。每个文件信息可以用<code class="language-plaintext highlighter-rouge">struct dirent</code>来表示。</p>

<p><strong>struct dirent</strong></p>

<pre><code class="language-C">struct dirent {
    int inum;
    char *name;
};
</code></pre>

<p>inum表示inode number；目录进入节点编号，<strong>如果inode的节点编号为0，则表示该文件不存在可以跳过</strong>。name就是表示文件名了。读取到该信息之后，就把文件名拼接到路径名上。再用<code class="language-plaintext highlighter-rouge">stat</code>函数获得该文件的信息，并打印出文件名，文件类型，文件的节点编号，文件的大小。</p>

<h3 id="52-仿写lsc">5.2 仿写ls.c</h3>

<p>如果说文件系统是一棵树，那么我认为每个文件和设备文件都是叶子节点，每个文件夹目录就是一个内节点。</p>

<h4 id="521-仿写fmtname函数">5.2.1 仿写fmtname函数</h4>

<p>唯一要注意的一点是，最后的memset的初始化的值是0，因为我们此时的目的不在是列表对齐了，而是纯纯的一个文件名！！</p>

<h4 id="522-仿写ls函数">5.2.2 仿写ls函数</h4>

<p>首先，我们也必须知道当前的目录路径是什么类型，所以也需要对目录进行打开并且获得他的文件描述符中的相关信息。如果该目录路径是一个文件或者是一个设备文件，我们就获得他的文件名和要查找的文件名进行比较，如果匹配，就输出当前的路径。不匹配，则继续。</p>

<p>如果该目录路径类型是一个文件夹，则我们要查找该文件夹中的所有文件，从该目录文件里每次读取一个<code class="language-plaintext highlighter-rouge">struct dirent</code>，如果读取内容有效，拼接文件名到当前目录路径上，然后继续搜素。</p>

<h4 id="523-防止死循环">5.2.3 防止死循环</h4>

<p>由于每个文件中都有<code class="language-plaintext highlighter-rouge">.</code>文件夹和<code class="language-plaintext highlighter-rouge">..</code>文件夹，分别表示当前文件夹和父文件夹。搜素并不需要访问父文件夹，所以<code class="language-plaintext highlighter-rouge">..</code>文件我们可以直接跳过，然后对于<code class="language-plaintext highlighter-rouge">.</code>文件夹，我们就不嫩直接跳过了（因为程序开始就是<code class="language-plaintext highlighter-rouge">.</code>文件夹，跳过就不用搜索辣:）。</p>

<p>为了解决这个问题，我们保存当前目录路径的iNode编号，以及即将要查找的文件路径的iNode编号，如果相同，则我们就不用再继续搜索这个文件夹。</p>

<h4 id="524-仿写出来的find函数">5.2.4 仿写出来的find函数</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">search</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">fmtname</span><span class="p">(</span><span class="n">path</span><span class="p">),</span> <span class="s">".."</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">],</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dirent</span> <span class="n">de</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">stat</span> <span class="n">st</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">fd</span>  <span class="o">=</span> <span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"find: cannot open %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fstat</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">st</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"find: cannot stat %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
        <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">T_FILE</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fmtname</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">T_DEVICE</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fmtname</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">T_DIR</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">DIRSIZ</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"find: path too long</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
                <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">strcpy</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

            <span class="n">p</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

            <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="sc">'/'</span><span class="p">;</span>

            <span class="k">while</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">de</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">inum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">memmove</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">DIRSIZ</span><span class="p">);</span>
                <span class="n">p</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

                <span class="k">struct</span> <span class="n">stat</span> <span class="n">prest</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">"find: cannot stat %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">.</span><span class="n">ino</span> <span class="o">==</span> <span class="n">prest</span><span class="p">.</span><span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">search</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>至此整体代码就基本实现了。</p>

<h3 id="53-代码实现">5.3 代码实现</h3>

<pre><code class="language-C">#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"

char *fmtname(char *path) {
    static char buf[DIRSIZ + 1];
    char *p;

    for (p = path + strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--);
    p++;

    if (strlen(p) &gt;= DIRSIZ) {
        return p;
    }

    memmove(buf, p, strlen(p));
    memset(buf + strlen(p), 0, DIRSIZ - strlen(p));

    return buf;
}

void search(char *path, const char *file) {

    if (strcmp(fmtname(path), "..") == 0) {
        return;
    }

    char buf[512], *p;
    int fd;
    struct dirent de;
    struct stat st;

    if ((fd  = open(path, 0)) &lt; 0) {
        fprintf(2, "find: cannot open %s\n", path);
        exit(1);
    }

    if (fstat(fd, &amp;st) &lt; 0) {
        fprintf(2, "find: cannot stat %s\n", path);
        close(fd);
        exit(1);
    }

    switch (st.type) {
        case T_FILE:
            if (strcmp(file, fmtname(path)) == 0) {
                fprintf(1, "%s\n", path);
            }
            break;
        case T_DEVICE:
            if (strcmp(file, fmtname(path)) == 0) {
                fprintf(1, "%s\n", path);
            }
            break;
        case T_DIR:
            if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof(buf)) {
                fprintf(2, "find: path too long\n");
                close(fd);
                exit(1);
            }

            strcpy(buf, path);

            p = buf + strlen(buf);

            *p++ = '/';

            while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) {
                if (de.inum == 0) {
                    continue;
                }

                memmove(p, de.name, DIRSIZ);
                p[DIRSIZ] = 0;

                struct stat prest;

                if (stat(buf, &amp;prest) &lt; 0) {
                    fprintf(2, "find: cannot stat %s\n", p);
                    continue;
                }

                if (st.ino == prest.ino) {
                    continue;
                }

                search(buf, file);
            }

            break;
        default:
            break;
    }

    close(fd);
}

int main(int argc, char *argv[]) {

    if (argc &lt; 2 || argc &gt; 3) {
        fprintf(2, "Usage: find &lt;filename&gt;\n");
        exit(1);
    }

    search(argv[1], argv[2]);

    exit(0);
}
</code></pre>

<h2 id="6-xargsmoderate">6 xargs(moderate)</h2>

<blockquote>
  <p>编写一个程序，实现linux xargs基础功能。</p>

  <p>xargs通常和管道使用，例如</p>

  <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo </span>bye too | xargs <span class="nb">echo </span>hello
</code></pre></div>  </div>

  <p>首先管道的左边执行<code class="language-plaintext highlighter-rouge">echo bye too</code>此时会从标准输出流中输出<code class="language-plaintext highlighter-rouge">bye too</code>。而管道右侧执行<code class="language-plaintext highlighter-rouge">xargs</code>程序，该程序从管道的左侧的输出读取信息（从该程序的标准输入流中读取），作为即将要运行的<code class="language-plaintext highlighter-rouge">echo</code>程序的扩展参数。</p>

  <p>即整个命令行相当于执行了<code class="language-plaintext highlighter-rouge">echo hello bye too</code>，所以打印出了<code class="language-plaintext highlighter-rouge">hello bye too</code>。</p>
</blockquote>

<h3 id="61-实现方式">6.1 实现方式</h3>

<h4 id="611-读取左侧的参数">6.1.1 读取左侧的参数</h4>

<p>定义一个全局变量buf来保存读取到的信息流。按照题目描述的要求，每一行就是一个参数，所以只要读到换行符，我们就将该换行符保存为<code class="language-plaintext highlighter-rouge">‘\0’</code>，表示一个字符串（即参数）的结束，并累计参数计数器。</p>

<h4 id="612-整合程序参数">6.1.2 整合程序参数</h4>

<p>新声明一个args字符指针数组，保存每个参数的起始地址。首先将命令行中本有的参数保存在args中，在从buf中读取累计的参数个数的参数的起始地址。</p>

<pre><code class="language-C">int argptr;
char *args[MAXARG];
char buf[512 * MAXARG];

void getargs() {
    char *p = buf;
    char ch;
    int count = 0;

    while (p &amp;&amp; read(0, &amp;ch, 1)) {
        if (ch == '\n') {
            count++;
            *p++ = '\0';
        } else {
            *p++ = ch;
        }
    }

    *p = '\0';

    if (read(0, &amp;ch, 1)) {
        fprintf(2, "xargs: args too long\n");
        exit(1);
    }

    if (count &gt; MAXARG) {
        fprintf(2, "xargs: args too long\n");
        exit(1);
    }

    p = buf;
    
    while (count--) {
        args[argptr++] = p;
        p += strlen(p);
        p++;
    }
}
</code></pre>

<p>整个程序的难点就在这里了。</p>

<h4 id="613-新建子进程">6.1.3 新建子进程</h4>

<p>用fork和exec运行程序即可。</p>

<h3 id="62-代码实现">6.2 代码实现</h3>

<pre><code class="language-C">#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/param.h"

int argptr;
char *args[MAXARG];
char buf[512 * MAXARG];

void getargs() {
    char *p = buf;
    char ch;
    int count = 0;

    while (p &amp;&amp; read(0, &amp;ch, 1)) {
        if (ch == '\n') {
            count++;
            *p++ = '\0';
        } else {
            *p++ = ch;
        }
    }

    *p = '\0';

    if (read(0, &amp;ch, 1)) {
        fprintf(2, "xargs: args too long\n");
        exit(1);
    }

    if (count &gt; MAXARG) {
        fprintf(2, "xargs: args too long\n");
        exit(1);
    }

    p = buf;
    
    while (count--) {
        args[argptr++] = p;
        p += strlen(p);
        p++;
    }
}

int main(int argc, char *argv[]) {

    for (int i = 1; i &lt; argc; ++i) {
        args[argptr++] = argv[i];
    }

    getargs();

    if (fork() == 0) {
        if (exec(argv[1], args) &lt; 0) {
            fprintf(2, "xargs: exec %s fail\n", argv[1]);
            exit(1);
        }
    }

    wait(0);

    exit(0);
}
</code></pre>

<h2 id="7-end">7 END</h2>

<p>整个lab就写完了，测试结果如下。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>== Test sleep, no arguments == 
$ make qemu-gdb
sleep, no arguments: OK (4.9s) 
== Test sleep, returns == 
$ make qemu-gdb
sleep, returns: OK (0.9s) 
== Test sleep, makes syscall == 
$ make qemu-gdb
sleep, makes syscall: OK (0.9s) 
== Test pingpong == 
$ make qemu-gdb
pingpong: OK (0.9s) 
== Test primes == 
$ make qemu-gdb
primes: OK (1.0s) 
== Test find, in current directory == 
$ make qemu-gdb
find, in current directory: OK (1.2s) 
== Test find, recursive == 
$ make qemu-gdb
find, recursive: OK (1.1s) 
== Test xargs == 
$ make qemu-gdb
xargs: OK (1.3s) 
== Test time == 
time: OK 
Score: 100/100
</code></pre></div></div>]]></content><author><name></name></author><category term="xv6" /><summary type="html"><![CDATA[1 Boot xv6]]></summary></entry><entry><title type="html">Lab file system</title><link href="http://localhost:4000/xv6/2024/02/20/lab-file-system.html" rel="alternate" type="text/html" title="Lab file system" /><published>2024-02-20T18:35:00+08:00</published><updated>2024-02-20T18:35:00+08:00</updated><id>http://localhost:4000/xv6/2024/02/20/lab-file-system</id><content type="html" xml:base="http://localhost:4000/xv6/2024/02/20/lab-file-system.html"><![CDATA[<h2 id="1-large-files-moderate">1 Large files (moderate)</h2>

<blockquote>
  <p>修改xv6现有的文件系统的inode相关代码，使该文件系统最大能够支持写65803个块。</p>
</blockquote>

<h3 id="11-原inode">1.1 原iNode</h3>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20221122210216963.png" alt="image-20221122210216963" /></p>

<p>原iNode有12个直接访问块，外加一个间接访问块；而这个间接访问块可以访问256个块。所以原iNode设计可以访问（12+256）个块。而我们现在减少一个直接访问块，增加一个二级间接访问块。一个二级间接访问块，可以访问（256*256）个块。极大的增加了可以访问的块数。</p>

<h3 id="13-新inode">1.3 新iNode</h3>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20221122212836417.png" alt="image-20221122212836417" /></p>

<p>新的iNode相比于原iNode也就是删去了一个直接访问块，增加了一个间接访问块。</p>

<h3 id="14-实现新inode">1.4 实现新iNode</h3>

<h4 id="141-修改相关宏和结构体">1.4.1 修改相关宏和结构体</h4>

<p>修改直接访问块的数量，增加二级间接访问宏，修改最大文件大小。</p>

<pre><code class="language-C">#define NDIRECT 11 //direct
#define NINDIRECT (BSIZE / sizeof(uint)) //single direct
#define NDINDIRECT (NINDIRECT * NINDIRECT) //double direct
#define MAXFILE (NDIRECT + NINDIRECT + NDINDIRECT)
</code></pre>

<p>修改iNode和dinode结构体的data block addresses的大小：</p>

<pre><code class="language-C">struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEVICE only)
  short minor;          // Minor device number (T_DEVICE only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+2];   // Data block addresses
};
</code></pre>

<pre><code class="language-C">struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT+2];
};
</code></pre>

<h4 id="142-修改bmap函数">1.4.2 修改bmap函数</h4>

<p>增加处理二级间接访问即可，可模仿一级间接访问的写法，如果地址不存在，就分配新的块；<strong>如果这个新的块被修改，要使用<code class="language-plaintext highlighter-rouge">log_write()</code>函数，使之能更新到磁盘中</strong>。</p>

<p>部分代码如下：</p>

<pre><code class="language-C">bn -= NINDIRECT;

if (bn &lt; NDINDIRECT) {
    if ((addr = ip-&gt;addrs[NDIRECT + 1]) == 0) {
        addr = balloc(ip-&gt;dev);
        if (addr == 0)
            return 0;
        ip-&gt;addrs[NDIRECT + 1] = addr;
    }
    bp = bread(ip-&gt;dev, addr);
    a = (uint*)bp-&gt;data;
    if ((addr = a[bn / NINDIRECT]) == 0) {
        addr = balloc(ip-&gt;dev);
        if (addr == 0)
            return 0;
        a[bn / NINDIRECT] = addr;
        log_write(bp);
    }
    cp = bread(ip-&gt;dev, addr);
    b = (uint*)cp-&gt;data;
    if ((addr = b[bn % NINDIRECT]) == 0) {
        addr = balloc(ip-&gt;dev);
        if (addr) {
            b[bn % NINDIRECT] = addr;
            log_write(cp);
        }
    }
    brelse(cp);
    brelse(bp);
    return addr;
}
</code></pre>

<h4 id="143-修改itrunc函数">1.4.3 修改itrunc函数</h4>

<p>增加删除二级间址块的功能，该部分代码也可以仿照一级间址来写。</p>

<p>部分代码如下：</p>

<pre><code class="language-C">if(ip-&gt;addrs[NDIRECT + 1]) {
    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + 1]);
    a = (uint*)bp-&gt;data;
    for (i = 0; i &lt; NINDIRECT; ++i) {
        if (a[i]) {
            cp = bread(ip-&gt;dev, a[i]);
            b = (uint *) cp-&gt;data;
            for (j = 0; j &lt; NINDIRECT; ++j) {
                if (b[j])
                    bfree(ip-&gt;dev, b[j]);
            }
            brelse(cp);
            bfree(ip-&gt;dev, a[i]);
        }
    }
    brelse(bp);
    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + 1]);
    ip-&gt;addrs[NDIRECT + 1] = 0;
}
</code></pre>

<p>然后bigfile测试通过。</p>

<h2 id="2-symbolic-links-moderate">2 Symbolic links (moderate)</h2>

<blockquote>
  <p>实现<code class="language-plaintext highlighter-rouge">symlink</code>的系统调用；另一种说法是，使xv6支持软链接(symbolic link)。</p>

  <p><code class="language-plaintext highlighter-rouge">symlink</code>在<code class="language-plaintext highlighter-rouge">C programmer's manual</code>(RTFM)中描述如下：</p>

  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>symlink() creates a symbolic link named linkpath which contains the string target.

Symbolic links are interpreted at run time as if the contents of the link had been substituted into the path being followed to find a file or directory.

Symbolic links may contain ..  path components, which (if used at the start of the link) refer to the parent directories of that in which the link resides.

A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent one; the latter case is known as a dangling link.

The  permissions  of  a symbolic link are irrelevant; the ownership is ignored when following the link, but is checked when removal or renaming of the link is requested and the
link is in a directory with the sticky bit (S_ISVTX) set.

If linkpath exists, it will not be overwritten.

</code></pre></div>  </div>

  <p>大致需要这么几点功能：</p>

  <ul>
    <li>该软链接的名字叫做<code class="language-plaintext highlighter-rouge">linkpath</code>，链接的事物的名字叫做<code class="language-plaintext highlighter-rouge">target</code>，这个事物不一定需要存在。（你只需要登记信息就行，登记成功就返回成功信息，登记失败返回失败信息）</li>
    <li>被链接的事物是一个文件或者是一个文件夹</li>
    <li>linkpath不可以重新，也就是调用这个系统调用时，这个linkpath不可以存在。</li>
  </ul>
</blockquote>

<h3 id="21-实现symlink">2.1 实现symlink</h3>

<h4 id="211-检查该系统调用的前提条件">2.1.1 检查该系统调用的前提条件</h4>

<p>用户是否提供了有效的两个参数，以及这个<code class="language-plaintext highlighter-rouge">linkpath</code>是否不存在。如果上述条件不满足，返回错误码-1。</p>

<h4 id="212-新建inode">2.1.2 新建iNode</h4>

<p>根据实验提供的提示：我们可以将这个软链接保存在一个iNode中，target保存在iiNode的<code class="language-plaintext highlighter-rouge">data block</code>中。</p>

<p>你可能会发现<code class="language-plaintext highlighter-rouge">ialloc</code>函数可以分配一个iNode节点，但是这个节点不会有数据块，需要用<code class="language-plaintext highlighter-rouge">balloc</code>函数分配一个，但是你会发现，<code class="language-plaintext highlighter-rouge">balloc</code>函数没法在系统调用函数中使用。</p>

<p>所以通过<code class="language-plaintext highlighter-rouge">RTFSC</code>法则发现，<code class="language-plaintext highlighter-rouge">sysfile.c</code>中的<code class="language-plaintext highlighter-rouge">create</code>函数起到了分配一个iNode的作用，并且返回一个<strong>上了锁</strong>的iNode。</p>

<h4 id="213-写入target">2.1.3 写入target</h4>

<p>当然，你通过<code class="language-plaintext highlighter-rouge">create</code>分配到了一个上锁的iNode之后，还是发现这个iNode没有分配数据块，但是你又一次的尝试了使用了balloc分配一个数据块，而且想用bread来读这个数据块。但是，两个问题，第一，balloc函数你还是无法使用；第二，bread返回的buf结构体不知道为啥在系统调用里不能使用了。<strong>Compile Error</strong></p>

<p>再次通过<strong>RTFSC</strong>法则发现，<code class="language-plaintext highlighter-rouge">fs.c</code>中的<code class="language-plaintext highlighter-rouge">writei</code>函数支持你向iNode中写入信息，而且系统调用可以正常的调用，所以问题解决啦。</p>

<p>看看<code class="language-plaintext highlighter-rouge">writei</code>函数：</p>

<pre><code class="language-C">// Write data to inode.
// Caller must hold ip-&gt;lock.
// If user_src==1, then src is a user virtual address;
// otherwise, src is a kernel address.
// Returns the number of bytes successfully written.
// If the return value is less than the requested n,
// there was an error of some kind.
int
writei(struct inode *ip, int user_src, uint64 src, uint off, uint n)
</code></pre>

<p>通过这个注释描述，就可以知道这个函数的用法了。off是指在iNode中偏移多少的位置开始写入数据。在这里，我们就希望在偏移量为0，即从头开始写入数据。</p>

<h4 id="214-代码">2.1.4 代码</h4>

<pre><code class="language-C">uint64
sys_symlink(void)
{
  char target[MAXPATH], path[MAXPATH];

  struct inode *ip;

  if(argstr(0, target, MAXPATH) &lt; 0 || argstr(1, path, MAXPATH) &lt; 0)
    return -1;

  if (namei(path) != 0) {
    return -1;
  }

  begin_op();
  if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) {
    end_op();
    return -1;
  }

  if (writei(ip, 0, (uint64)target, 0, MAXPATH) &lt; 0) {
    ip-&gt;nlink = 0;
    iupdate(ip);
    iunlockput(ip);
    end_op();
    return -1;
  }
  iunlockput(ip);
  end_op();

  return 0;
}
</code></pre>

<h3 id="22-修改sys_open">2.2 修改sys_open</h3>

<blockquote>
  <p>在之前的open系统调用中，并没有支持对inode类型为<code class="language-plaintext highlighter-rouge">T_SYMLINK</code>的支持，修改sys_open，以支持symlink。</p>
</blockquote>

<h4 id="221-o_nofollow">2.2.1 O_NOFOLLOW</h4>

<p>盲猜，o_nofollow在unix上也有，且也在open调用中使用，于是我们<code class="language-plaintext highlighter-rouge">man open</code>来看看文档。</p>

<p>文档中对<code class="language-plaintext highlighter-rouge">O_NOFOLLOW</code>的描述如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>O_NOFOLLOW
If  pathname is a symbolic link, then the open fails, with the error ELOOP.  Symbolic links in earlier components of the pathname will still be followed.  (Note that the
ELOOP error that can occur in this case is indistinguishable from the case where an open fails because there are too many symbolic links found while resolving components
in the prefix part of the pathname.)

This flag is a FreeBSD extension, which was added to Linux in version 2.1.126, and has subsequently been standardized in POSIX.1-2008.
</code></pre></div></div>

<p>文档中描述的意思是，如果这个标签被设置，则路径是一个软链接的话，就打开错误。</p>

<p><strong>但是在题目中的hints中，该标签的意思是，直接返回这个软链接即可，所以我们只能按照实验的意思写了。</strong></p>

<h4 id="222-实现o_nofollow">2.2.2 实现O_NOFOLLOW</h4>

<p>当系统调用判断了没有创建标记时，且同时打开了路径对应的inode时候(sysfile.c: 335)，我们判断该inode是不是一个软链接。如果是软链接，我们进行以下处理：</p>

<p>判断是否有<code class="language-plaintext highlighter-rouge">O_NOFOLLOW</code>标记，如果有，直接返回这个软标记。</p>

<p>如果有该标记，打开软链接中target，如果target也是一个软链接，重复该操作，直到链接到一个非软链接的inode。</p>

<p><strong>按照hints，如果软链接到10次，则返回错误</strong></p>

<h4 id="224-代码">2.2.4 代码</h4>

<pre><code class="language-C">uint64
sys_open(void)
{
  char path[MAXPATH];
  int fd, omode;
  struct file *f;
  struct inode *ip;
  int n;

  argint(1, &amp;omode);
  if((n = argstr(0, path, MAXPATH)) &lt; 0)
    return -1;

  begin_op();

  if(omode &amp; O_CREATE){
    ip = create(path, T_FILE, 0, 0);
    if(ip == 0){
      end_op();
      return -1;
    }
  } else {
    if((ip = namei(path)) == 0){
      end_op();
      return -1;
    }
    ilock(ip);
    if(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY){
      iunlockput(ip);
      end_op();
      return -1;
    }

      // change here
    if (ip-&gt;type == T_SYMLINK) {
      if (!(omode &amp; O_NOFOLLOW)) {
        int deep = 0;

        while (1) {
          deep++;

          if (deep == 10) {
            iunlockput(ip);
            end_op();
            return -1;
          }

          if (readi(ip, 0, (uint64)path, 0, MAXPATH) &lt; 0) {
            iunlockput(ip);
            end_op();
            return -1;
          }
          iunlockput(ip);
          
          if ((ip = namei(path)) == 0) {
            end_op();
            return -1;
          }

          ilock(ip);
          if (ip-&gt;type != T_SYMLINK) {
            break;
          }
        }
      }
    }
      
      // end here
  }

  if(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; 0 || ip-&gt;major &gt;= NDEV)){
    iunlockput(ip);
    end_op();
    return -1;
  }

  if((f = filealloc()) == 0 || (fd = fdalloc(f)) &lt; 0){
    if(f)
      fileclose(f);
    iunlockput(ip);
    end_op();
    return -1;
  }

  if(ip-&gt;type == T_DEVICE){
    f-&gt;type = FD_DEVICE;
    f-&gt;major = ip-&gt;major;
  } else {
    f-&gt;type = FD_INODE;
    f-&gt;off = 0;
  }
  f-&gt;ip = ip;
  f-&gt;readable = !(omode &amp; O_WRONLY);
  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);

  if((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE){
    itrunc(ip);
  }

  iunlock(ip);
  end_op();

  return fd;
}
</code></pre>

<p>其实这个实验没有考虑太多的细节，本来想看看编译能不能过，结果直接把测试过了，比较意外。</p>

<h2 id="3-end">3 END</h2>

<p>意外的结束了实验，测试结果如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>== Test running bigfile ==
$ make qemu-gdb
running bigfile: OK (133.9s)
== Test running symlinktest ==
$ make qemu-gdb
(0.9s)
== Test   symlinktest: symlinks ==
  symlinktest: symlinks: OK
== Test   symlinktest: concurrent symlinks ==
  symlinktest: concurrent symlinks: OK
== Test usertests ==
$ make qemu-gdb
usertests: OK (218.3s)
== Test time ==
time: OK
Score: 100/100
</code></pre></div></div>]]></content><author><name></name></author><category term="xv6" /><summary type="html"><![CDATA[1 Large files (moderate)]]></summary></entry><entry><title type="html">分支预测</title><link href="http://localhost:4000/cpu/2024/02/20/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B.html" rel="alternate" type="text/html" title="分支预测" /><published>2024-02-20T18:22:00+08:00</published><updated>2024-02-20T18:22:00+08:00</updated><id>http://localhost:4000/cpu/2024/02/20/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B</id><content type="html" xml:base="http://localhost:4000/cpu/2024/02/20/%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B.html"><![CDATA[<blockquote>
  <p>对《超标量处理器设计》的第4章分支预测一些笔记整理。</p>
</blockquote>

<p>思维导图：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/branch%20predict%20draft.jpg" alt="branch predict draft" /></p>

<h2 id="分支预测的类型">分支预测的类型</h2>

<p>不用等到分支指令的结果真的被计算出来，而是提前就预测结果的过程就是分支预测。分支预测分为静态分支预测以及动态分支预测。</p>

<ul>
  <li>静态分支预测：认为分支预测一定发生跳转或者一定不发生跳转的预测是静态分支预测。</li>
  <li>动态分支预测：并不会简单地预测分支指令一直发生跳转或者不跳转，而是会根据分支指令在过去的一段时间的执行情况来决定预测的结果。</li>
</ul>

<p>要预测首先需要知道该指令是一条分支指令。获取到这个信息的方式是在取指的时候先进行预译码。</p>

<h2 id="分支指令的方向预测">分支指令的方向预测</h2>

<h3 id="基于两位饱和计数器的分支预测">基于两位饱和计数器的分支预测</h3>

<p>原型是基于一位计数器的分支预测，即上次怎么做我这次就怎么做。这种方式的问题在于，一但分支预测具有一定周期性规律，这种预测方式的准确率就很低。对其改进的方式就是，再添加一位，使用两位饱和计数器。</p>

<h4 id="原理">原理</h4>

<p>此时，计数器就会出现以下四种情况：<code class="language-plaintext highlighter-rouge">00</code>，<code class="language-plaintext highlighter-rouge">01</code>，<code class="language-plaintext highlighter-rouge">10</code>，<code class="language-plaintext highlighter-rouge">11</code>，我们也对其定义为四种状态，强不跳转，弱不跳转，弱跳转，强跳转。当在其状态的时候，分别采用以下的预测策略：不跳转，不跳转，跳转，跳转。这四个状态之间的转换状态机图如下：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/2bit%20s0.jpg" alt="2bit s0" /></p>

<p>还有两种比较常用的状态机：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/2bit%20s1.jpg" alt="2bit s1" /></p>

<p>那么最初的时候应该使用什么状态呢？一般来说，会使用两个弱状态中的一种。</p>

<p><strong>这种分支预测的好处：</strong>偶尔一次的分支方向变化不会影响分支预测，准确率很高。所以该方法也是现在主流的分支预测方法。</p>

<h4 id="预测">预测</h4>

<p>有了原理，我们如何对一条分支指令进行方向预测呢？每一条指令都有一个PC值，我们可以以PC值为索引，建立一个数组，存放每个PC的两位饱和计数器。我们称这样一个数组为<code class="language-plaintext highlighter-rouge">PHT</code>（Pattern History Table）。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/PHT.jpg" alt="PHT" /></p>

<p>但是这样的做法有一个问题，PC的范围非常的大，不可能为全部的PC提供两位饱和计数器存储的位置，所以我们需要对PC值进行一些处理。一般会有以下几种处理方式：</p>

<ul>
  <li>切片：选取PC二进制中的k位，作为索引值。</li>
  <li>哈希：使用hash算法，将PC转化为一个较小的值。</li>
</ul>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/PHT+slice.jpg" alt="PHT+slice" /></p>

<p>这样操作之后，难免会碰到这种情况：两个PC值对应的PHT的entry是一样的。<strong>这就是重名问题</strong>。如果重名对跳转的结果不产生影响，则该重名是一个中立的重名；如果该重名对跳转的结果造成了影响，则该重名是一个破坏性的重名。</p>

<h4 id="总结">总结</h4>

<p>该方法实现简单，准确率高。<strong>但是准确率有极限值，不超过98%。</strong></p>

<h3 id="基于局部历史的分支预测">基于局部历史的分支预测</h3>

<p>可以说，基于两位饱和计数器的分支预测器是该方法的一种特殊情况，即不考虑历史分支情况。现在我们要考虑一条指令历史的执行情况，就产生了基于局部历史的分支预测。</p>

<h4 id="原理-1">原理</h4>

<p>为每一条分支指令维护一个分支历史寄存器（Branch History Register），位宽为b位，表示历史b次执行情况。假设$b = 4$，寄存器的值为<code class="language-plaintext highlighter-rouge">1000</code>，表示执行情况为跳转，不跳转，不跳转，不跳转。</p>

<p>然后，为每一种历史4次执行情况维护一个2为饱和计数器，根据该计数器的值决定是否跳转。饱和计数器的个数为$2 ^ b$个。此时的原理和基于两位饱和计数器的分支预测原理一样了。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/1bht.jpg" alt="1bht" /></p>

<p>如果我们为每个PC都维护一个BHT，同时也维护一个PHT，则效果会如下：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/mbht.jpg" alt="mbht" /></p>

<p>这样做法会导致硬件开销非常的大，我们可以进行一些改进。</p>

<h4 id="改进">改进</h4>

<p>第一种方式，我们仍然维护多个PHT，但不再使用PC寻找BHR和PHT。仿照之前的做法，对PC进行切片，取其中的p位寻址BHR，其中的q位来寻址PHT。此时我们就只需要维护$2^q$个PHT。<strong>但是会引入重名问题</strong>。</p>

<p>第二种方式，我们只用维护一个PHT，但是会增加PHT的entry的个数。此时的问题是，我们如何根据PC获取一个entry的索引值。有一下几种方式：</p>

<ul>
  <li>PC的哈希值拼接BHR值。$index = cat(hash(PC), BHR(hash(PC)))$</li>
  <li>PC的部分值拼接BHR部分值。$index = cat(PC[k, 0], BHR(hash(PC))[k, 0])$</li>
  <li>PC的部分值拼接BHR部分值。$index = PC[k, 0] \bigotimes BHR(hash(PC))[k, 0]$</li>
</ul>

<p>通常来讲，第三种方式会更优。但是三种方式也会不同程度上引入重名问题。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/ubhr.jpg" alt="ubhr" /></p>

<p>最后一个问题，BHR的位宽值应该取多少呢？这个值取决于分支指令跳转的循环周期。实际上，这个值是无法确定的。所以位宽越大，预测的结果就会更加准确。但是，分支预测训练的时间也会增加。</p>

<h3 id="基于全局历史的分支预测">基于全局历史的分支预测</h3>

<p>假设将基于局部历史的分支预测中PC全部哈希成一个值，则全局就只有一个BHR了。这个时候就是基于全局历史的分支预测原型了。</p>

<h4 id="原理-2">原理</h4>

<p>其实和基于部分历史的分支预测的原理一样，这里使用的全部分支指令的历史跳转情况。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/ghr.jpg" alt="ghr" /></p>

<p>这个时候，我们并没有使用上PC这个值，导致重名的概率会很高。</p>

<h4 id="改进-1">改进</h4>

<p>利用PC，建立多个PHT，使用PC索引PHT。效果如下图：<img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/aghr.jpg" alt="aghr" /></p>

<p>用PC做索引硬件开销大，我们可以用哈希函数优化一下：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/hghr.jpg" alt="hghr" /></p>

<p>同样，我们也可以仿照基于局部历史的分支预测的改进方式，使用一个PHT，扩大entry的个数，使用一些映射方式将PC转化成索引：</p>

<ul>
  <li>位拼接：将PC的哈希值和GHR的值拼接。</li>
  <li>异或：将PC的哈希值和GHR异或。</li>
</ul>

<p>在大多数情况下，使用异或的方式会更优。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/xghr.jpg" alt="xghr" /></p>

<h3 id="竞争的分支预测">竞争的分支预测</h3>

<p>基于局部历史的分支预测以及基于全局历史的分支预测各有优缺点，都有自身的局限性，有些分支指令使用基于局部历史的分支预测会有更好的效果，而有些指令使用基于全局历史的分支预测会有更好的效果。此时，可以设计一种方式，根据分支指令的执行情况来选择合适的分支预测的方式，称为竞争的分支预测。</p>

<h4 id="原理-3">原理</h4>

<p>既然分支指令有跳转和不跳转两种情况，可以使用两位饱和计数器来预测；那么，我们可以将分支指令的预测方式分为两种情况，一种基于局部历史的分支预测，一种基于全局历史的分支预测，也可以使用两位饱和计数器来选择使用那种分支预测的方式。针对分支预测方式的PHT，我们称之为CPHT（Choice PHT）。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/cpht.jpg" alt="cpht" /></p>

<p>CPHT里的状态机也和PHT的状态机类似，分为强使用BHR，弱使用BHR，弱使用GHR，强使用GHR。状态机图如下：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/cpht%20states.jpg" alt="cpht states" /></p>

<h3 id="分支预测的更新">分支预测的更新</h3>

<p>完成分支指令之后，需要对分支预测的历史寄存器以及两位饱和计数器进行更新。</p>

<h4 id="历史寄存器的更新">历史寄存器的更新</h4>

<p>历史寄存器的更新有三种更新方式：</p>

<ul>
  <li>在取指阶段对预测的结果进行更新</li>
  <li>在分支指令被实际算出来的时候更新</li>
  <li>在分支指令退休的时候更新</li>
</ul>

<p>第一种方式更新的结果显而易见是不一定正确的，因为分支指令的结果不确定；第二种方式结果上是正确的，但是有延迟可能会导致该分支指令下面几条指令的预测错误；第三种方式是最保守的，当然也也是最安全的，同样也会出现第二种情况出现的问题。</p>

<p>但是我们想尽快的使用新的分支结果怎么办？此时还是需要在取指的时候对预测结果更新。那么会引入新的问题，预测错误了怎么恢复呢？</p>

<p>书上提供了两种恢复方式：</p>

<ul>
  <li>提交阶段恢复法</li>
  <li>checkpoint恢复法</li>
</ul>

<p>第一种恢复方法是在提交的时候更新分支预测器，即在译码和提交阶段各准备一个GHR寄存器。在译码阶段的GHR寄存器是投机性的，因此不准确。当分支预测错误的时候，使用提交阶段的GHR来更新译码阶段的GHR。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/creb.jpg" alt="creb" /></p>

<p>第二种方式是在分支指令计算出来之后对分支预测进行恢复。当在译码阶段预测之后，将预测结果写入到译码阶段的GHR中，同时，也将预测的反结果写到一个FIFO存储器中，当分支预测失败的时候，直接从FIFO中拿出恢复译码阶段的GHR。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/cp%20prin.jpg" alt="cp prin" /></p>

<p>书上总结来讲，在基于全局历史的分支预测方法中，在取指阶段根据分支预测的结果来更新GHR是最合适的，他利用了分支指令之间存在的相关性。而在基于局部历史的分支预测方法中，可以在分支指令退休的时候更新BHR，这样可以简化设计，也不会对处理器性能造成太大的影响。</p>

<h4 id="饱和计数器的更新">饱和计数器的更新</h4>

<p>一般在分支指令退休的时候对PHT中的饱和计数器进行更新。</p>

<h2 id="分支指令的目标预测">分支指令的目标预测</h2>

<p>分支指令分为两种，直接跳转指令以及间接跳转指令。</p>

<h3 id="直接跳转指令的分支预测">直接跳转指令的分支预测</h3>

<p>对于直接跳转的分支指令，他们的目标地址是PC相关的，偏移量以立即数的形式存储在指令中，所以目标地址也是固定的。等同于，PC值映射到一个目标地址值。</p>

<h4 id="原理-4">原理</h4>

<p>联想到缓存，是内存地址映射到一个数据。这里，我们把PC当作地址，目标地址当作数据。那么，我们可以用缓存的思想来解决这个问题。这里的缓存，我们就称之为 BTB（Branch Target Buffer）。</p>

<p>缓存需要的要素，有效位，表示该行缓存有效；tag，用以确定该缓存行对应的地址值，此处称为BIA（Branch Instruction Address）；数据块，保存目标跳转地址，此处称之为BTA（Branch Target Address）。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/btb%20demo.jpg" alt="btb demo" /></p>

<p>类似于数据缓存，我们将PC分成<code class="language-plaintext highlighter-rouge">index</code>和<code class="language-plaintext highlighter-rouge">tag</code>两个部分，如下图所示：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/btb%20pc.jpg" alt="btb pc" /></p>

<p>缓存都会遇到一个问题就是重名问题，解决方式就是设计成多路。分支预测需要尽快的完成，所以这里的路数要尽可能小。一般采用2路缓存。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20240221115109704.png" alt="image-20240221115109704" /></p>

<p>tag对应的是BIA部分，需要对其进行压缩处理。常用的方式：切片，哈希，异或。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20240221111956142.png" alt="image-20240221111956142" /></p>

<h4 id="btb缺失的处理">BTB缺失的处理</h4>

<ul>
  <li>停止执行：直到这条分支指令的目标地址被计算出来为止。</li>
  <li>继续执行：按照顺序执行方式执行指令。</li>
</ul>

<h3 id="间接跳转指令的预测">间接跳转指令的预测</h3>

<p>对于间接跳转指令，他们的目标地址来自于通用寄存器，是经常变化的，所以无法通过BTB对它的目标地址进行准确的预测。所幸的是，打啊部分间接跳转类型的分支指令都是用来进行子程序调用的CALL/RETURN指令，这两个指令是有规律可循的。</p>

<h4 id="原理-5">原理</h4>

<p>当调用一次call指令的时候，后续程序可能会调用与call指令对应的return指令，有LIFO的效果。故我们可以用栈来维护call指令执行的下一条指令的地址，当遇到return指令的时候，从栈中弹出下一跳指令的地址。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20240221114449797.png" alt="image-20240221114449797" /></p>

<p>需要考虑的问题，栈的大小是多少。如果大小太小，则能保存的地址不多。当嵌套层数较大的时候，保存的地址就会被覆盖，导致后续的分支预测失败。一般采用的大小为4。</p>

<h4 id="改进-2">改进</h4>

<p>在程序中，其实还存在这样一种情况：函数自己调用自己！此时，return的地址都是一样，我们就没有必要每次都用一个栈空间在存储这个地址。我们可以在栈上维护计数器，来表示每个栈空间上的地址需要调用的次数。这样栈上能保存的个数就不一定是4了。</p>

<h3 id="其他分支指令的预测">其他分支指令的预测</h3>

<p>其他分支就没固定的目标地址，但是我们也可以借鉴基于局部历史的分支预测方式。之前是预测是否发生跳转，此时，我们预测跳转的目标地址，只需要将PHT里保存的两位饱和计数器换成目标地址即可。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20240221115609641.png" alt="image-20240221115609641" /></p>

<h2 id="分支预测失败时的恢复">分支预测失败时的恢复</h2>

<p>有两种方法：</p>

<ul>
  <li>基于ROB（Re-Order Buffer）进行复制预测失败的状态恢复：遇到预测错误的分支指令时，停止后续的取指操作。然后等待已经发射的指令进入到ROB中，将所有分支指令之后的指令抹除掉。这种方式虽然惩罚过大，但是实现简单，硬件开销小，是一种比较折中的方案。</li>
</ul>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20240221135824002.png" alt="image-20240221135824002" /></p>

<ul>
  <li>使用checkpoint方法进行恢复：遇到分支指令之后，将处理器的状态保存起来，主要是保存寄存器重命名中使用的映射表，预测的分支指令下一条指令的PC值等。这种方法能够快速恢复处理器的状态，效率高，但是硬件消耗就会增大。但是还会有一个问题，需要抹除掉流水线中已经发射的指令。此时就需要使用tag list的方法。</li>
</ul>

<h3 id="tag-list">tag list</h3>

<p>为每一条分支指令提供一个编号tag，所有在此指令之后都使用这个tag。当遇到分支预测错误的时候，使用该抹除ROB中的指令。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20240221140704680.png" alt="image-20240221140704680" /></p>

<p>那么如何来维护可以使用的tag呢？我们维护两个队列FIFO，一个空闲tag队列，一个tag队列。需要编号的时候，从空闲tag队列中取出一个tag，将其放入tag队列中；当一个tag不再被使用的时候，例如退休和分支预测错误，将其从tag队列中取出，并放入到空闲tag队列中。</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20240221141315290.png" alt="image-20240221141315290" /></p>]]></content><author><name></name></author><category term="CPU" /><summary type="html"><![CDATA[对《超标量处理器设计》的第4章分支预测一些笔记整理。]]></summary></entry><entry><title type="html">Configure your terminal</title><link href="http://localhost:4000/terminal/2024/02/16/configure-your-terminal.html" rel="alternate" type="text/html" title="Configure your terminal" /><published>2024-02-16T15:01:00+08:00</published><updated>2024-02-16T15:01:00+08:00</updated><id>http://localhost:4000/terminal/2024/02/16/configure-your-terminal</id><content type="html" xml:base="http://localhost:4000/terminal/2024/02/16/configure-your-terminal.html"><![CDATA[<blockquote>
  <p>抛弃<code class="language-plaintext highlighter-rouge">bash</code>，享受<code class="language-plaintext highlighter-rouge">zsh</code></p>

  <p><code class="language-plaintext highlighter-rouge">&gt;</code>表示命令行</p>

  <p>需要从<code class="language-plaintext highlighter-rouge">github</code>下载一些工具</p>

  <p>更多好的插件遇到了尽量会在这个文档中补充</p>
</blockquote>

<h2 id="nerd-font">Nerd Font</h2>

<blockquote>
  <p>Iconic font aggregator, collection, and patcher</p>

  <p>提供了大量的图标，也提供了很多编程用的字体。</p>

  <p>安装这些字体，以便下面这些插件的效果可以在你的终端上正常显示。</p>

  <p>安装字体后，需要修改系统字体选项；或者，只修改终端的字体选项。</p>
</blockquote>

<p><img src="https://www.nerdfonts.com/assets/img/sankey-glyphs-combined-diagram.png" alt="nerd" /></p>

<h3 id="下载">下载</h3>

<p>官网：<a href="https://www.nerdfonts.com/">nerd font</a></p>

<p>选择自己喜欢的字体下载，并在系统中安装。如果你GUI桌面，可以直接打开下载的字体文件，并点击安装。如果用的非GUI桌面，参考下面示例。</p>

<p>如果你有选择恐惧症，可以使用下面推荐设置（但不是最好的）</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">mkdir</span> <span class="nt">-p</span> ~/.local/share/fonts
<span class="o">&gt;</span> <span class="nb">cd</span> ~/.local/share/fonts <span class="o">&amp;&amp;</span> curl <span class="nt">-fLo</span> <span class="s2">"Droid Sans Mono for Powerline Nerd Font Complete.otf"</span> https://github.com/ryanoasis/nerd-fonts/raw/master/patched-fonts/DroidSansMono/complete/Droid%20Sans%20Mono%20Nerd%20Font%20Complete.otf
<span class="o">&gt;</span> fc-cache <span class="nt">-f</span> <span class="nt">-v</span>
</code></pre></div></div>

<h3 id="设置默认字体">设置默认字体</h3>

<p>系统设置：在你的系统设置里搜索字体选项。实在不会，试试<code class="language-plaintext highlighter-rouge">STFW</code>方法？</p>

<p>具体每个终端的修改方法：https://github.com/romkatv/powerlevel10k#manual-font-installation。</p>

<h2 id="zsh">Zsh</h2>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">zsh</code>由<code class="language-plaintext highlighter-rouge">Paul Falstad</code>开发，但取名于<code class="language-plaintext highlighter-rouge">Zhong Shao</code>教授。</p>
</blockquote>

<h3 id="安装">安装</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">sudo </span>apt update<span class="p">;</span> <span class="nb">sudo </span>apt <span class="nb">install </span>zsh
</code></pre></div></div>

<p>设置<code class="language-plaintext highlighter-rouge">zsh</code>为你的默认<code class="language-plaintext highlighter-rouge">shell</code>：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">sudo </span>chsh <span class="nt">-s</span> <span class="si">$(</span><span class="nb">sudo </span>which zsh<span class="si">)</span>
</code></pre></div></div>

<p>重启电脑后可完成设置。</p>

<h3 id="zsh-框架">zsh 框架</h3>

<blockquote>
  <p>Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with thousands of helpful functions, helpers, plugins, themes, and a few things that make you shout…</p>

  <p>“Oh My ZSH!”</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">oh my zsh</code>官方效果图：</p>

<p><img src="https://cloud.githubusercontent.com/assets/2618447/6316862/70f58fb6-ba03-11e4-82c9-c083bf9a6574.png" alt="zsh" /></p>

<h4 id="获取oh-my-zsh">获取<code class="language-plaintext highlighter-rouge">Oh My ZSH</code></h4>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> sh <span class="nt">-c</span> <span class="s2">"</span><span class="si">$(</span>curl <span class="nt">-fsSL</span> https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh<span class="si">)</span><span class="s2">"</span>
</code></pre></div></div>

<p>重启<code class="language-plaintext highlighter-rouge">shell</code>，你会看到默认配置的<code class="language-plaintext highlighter-rouge">oh my zsh</code>。现在看看用户的主目录的<code class="language-plaintext highlighter-rouge">.zshrc</code>文件，你基本可以靠自己阅读配置注解改改他的默认配置。</p>

<p><strong>从<code class="language-plaintext highlighter-rouge">.bashrc</code>中复制你原来自己增加的配置，原来自带的配置不要复制</strong>，尤其是<code class="language-plaintext highlighter-rouge">PATH</code>这样的配置（否则，你会发现原来<code class="language-plaintext highlighter-rouge">bash</code>可以运行的程序在<code class="language-plaintext highlighter-rouge">zsh</code>中提示不存在该命令？）。像<code class="language-plaintext highlighter-rouge">.zshrc</code>的第一个配置，你需不需要加上<code class="language-plaintext highlighter-rouge">~/.local/bin</code>呢？</p>

<h4 id="主题">主题</h4>

<p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">themes</a>，这里有完整的<code class="language-plaintext highlighter-rouge">zsh</code>自带主题介绍，选择你自己喜欢的吧。在页面的最下端还有非自带的主题的介绍，这些非自带主题就需要自己花时间折腾，但是最终效果一般会比自带的好，比如下面推荐的非自带主题。</p>

<p><strong>推荐</strong></p>

<p>主题和官网链接：<a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a></p>

<p>官方效果图：</p>

<p><img src="https://raw.githubusercontent.com/romkatv/powerlevel10k-media/master/prompt-styles-high-contrast.png" alt="p10k" /></p>

<p>安装：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> git clone <span class="nt">--depth</span><span class="o">=</span>1 https://github.com/romkatv/powerlevel10k.git <span class="k">${</span><span class="nv">ZSH_CUSTOM</span><span class="k">:-</span><span class="nv">$HOME</span><span class="p">/.oh-my-zsh/custom</span><span class="k">}</span>/themes/powerlevel10k
</code></pre></div></div>

<p>之后，修改<code class="language-plaintext highlighter-rouge">.zshrc</code>中的主题选项为<code class="language-plaintext highlighter-rouge">p10k</code>。</p>

<p>配置方法：</p>

<p>再次重新运行<code class="language-plaintext highlighter-rouge">zsh</code>会有<code class="language-plaintext highlighter-rouge">p10k</code>引导教程。更细的配置（比如添加显示的内容，修改分隔符号等等）请查看官方文档，网页连接已经在超连接中给出。</p>

<h4 id="插件">插件</h4>

<p><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Plugins">plugins</a>，这里有完整的插件介绍，选择你需要的插件来提高你的工作效率。</p>

<p><strong>推荐</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">git</code>：一些<code class="language-plaintext highlighter-rouge">git</code>的快捷操作。</li>
  <li><code class="language-plaintext highlighter-rouge">zsh-syntax-highlighting</code>：<code class="language-plaintext highlighter-rouge">shell</code>语法高亮，这样你就不会一直敲着白色的命令辣。<strong>需要自己搜索安装，不能在设置中直接设置</strong>，链接：<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syhntax-hightlighting</a></li>
  <li><code class="language-plaintext highlighter-rouge">zsh-autosuggestions</code>：命令建议，怕忘记之前输入过的命令，试试这个吧，还可以一键补全。<strong>需要自己搜索安装，不能在设置中直接设置</strong>，链接：<a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></li>
  <li><code class="language-plaintext highlighter-rouge">colored-man-pages</code>：每次看<code class="language-plaintext highlighter-rouge">man</code>的时候只有单调的文本？这个让你<code class="language-plaintext highlighter-rouge">man</code>阅读的更加舒服。</li>
  <li><code class="language-plaintext highlighter-rouge">tmux</code>：一些<code class="language-plaintext highlighter-rouge">tmux</code>的快捷操作。</li>
  <li><code class="language-plaintext highlighter-rouge">web-search</code>：有了他，你就可以在终端百度或者必应或者谷歌辣。</li>
  <li><code class="language-plaintext highlighter-rouge">autojump</code>：结合<code class="language-plaintext highlighter-rouge">autojump</code>，让您更加方便地在文件夹之间进行跳转。</li>
</ul>

<h2 id="tmux">Tmux</h2>

<blockquote>
  <p>宁愿开多个终端/ssh连接, 也不愿意花时间找找有没有tmux ，</p>

  <p>于是用鼠标来回切换, 浪费不必要的时间。 ——出自ysyx</p>
</blockquote>

<p>从引语就知道为什么要用<code class="language-plaintext highlighter-rouge">tmux</code>了吧。</p>

<p><code class="language-plaintext highlighter-rouge">tmux wiki</code>：https://github.com/tmux/tmux/wiki</p>

<h3 id="安装-1">安装</h3>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">sudo </span>apt <span class="nb">install </span>tmux
</code></pre></div></div>

<h3 id="配置">配置</h3>

<p>在你的主目录下创建<code class="language-plaintext highlighter-rouge">.tmux.conf</code>，初步的配置：</p>

<pre><code class="language-\">set -g prefix C-a # 设置前缀键，默认的C-b有点不人性化 

# 新建窗口用父亲的工作目录
bind-key c new-window -c "#{pane_current_path}"
bind-key % split-window -h -c "#{pane_current_path}"
bind-key '"' split-window -c "#{pane_current_path}"

# 导航方式如同vi，默认是emac
set-window-option -g mode-keys vi
</code></pre>

<h3 id="插件-1">插件</h3>

<blockquote>
  <p>默认的下面的状<code class="language-plaintext highlighter-rouge">tmux</code>太丑？试试<code class="language-plaintext highlighter-rouge">.tmux</code>或者是<code class="language-plaintext highlighter-rouge">powerline</code>。</p>
</blockquote>

<h4 id="tmux-1">.tmux</h4>

<blockquote>
  <p>有<code class="language-plaintext highlighter-rouge">oh my zsh</code>，当然就有<code class="language-plaintext highlighter-rouge">oh my tmux</code>（毫无逻辑关系）。<code class="language-plaintext highlighter-rouge">.tmux</code>就是这样的<code class="language-plaintext highlighter-rouge">oh my tmux</code>。</p>

  <p>同时他也是可以<code class="language-plaintext highlighter-rouge">tmux</code>的配置包。</p>
</blockquote>

<p>仓库地址：https://github.com/gpakosz/.tmux</p>

<p>官方效果图：</p>

<p><img src="https://cloud.githubusercontent.com/assets/553208/19740585/85596a5a-9bbf-11e6-8aa1-7c8d9829c008.gif" alt="tmux" /></p>

<h5 id="安装-2">安装</h5>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">cd</span>
<span class="o">&gt;</span> git clone https://github.com/gpakosz/.tmux.git
<span class="o">&gt;</span> <span class="nb">ln</span> <span class="nt">-s</span> <span class="nt">-f</span> .tmux/.tmux.conf
<span class="o">&gt;</span> <span class="nb">cp</span> .tmux/.tmux.conf.local <span class="nb">.</span>
</code></pre></div></div>

<p><strong>不要忘记命令中的点</strong></p>

<h5 id="配置-1">配置</h5>

<p><code class="language-plaintext highlighter-rouge">.tmux.conf.local</code>文件已经有详细的注释，可以按照注释修改配置文件。</p>

<p>比如，修改状态块分隔符，文件中搜索<code class="language-plaintext highlighter-rouge">seperator</code>。</p>

<h4 id="powerline">powerline</h4>

<blockquote>
  <p>全面的状态栏工具，不仅仅只向<code class="language-plaintext highlighter-rouge">tmux</code>提供，同时也向<code class="language-plaintext highlighter-rouge">bash, zsh, nvim</code>等提供状态栏。</p>
</blockquote>

<h5 id="安装-3">安装</h5>

<p>安装方法见<a href="https://powerline.readthedocs.io/en/master/installation.html">官方文档</a></p>

<h5 id="tmux状态栏">tmux状态栏</h5>

<p>安装方法见<a href="https://powerline.readthedocs.io/en/master/usage/other.html#tmux-statusline">官方文档</a></p>

<h5 id="配置-2">配置</h5>

<p>这个就需要自己阅读<a href="https://powerline.readthedocs.io/en/master/configuration.html">配置文档</a>，然后修改或着自己编写相应的代码了。</p>

<h2 id="vim">Vim</h2>

<blockquote>
  <p>还在使用普通编辑器，还在用鼠标或者键盘上下进行代码片段跳跃？来用用<code class="language-plaintext highlighter-rouge">vi</code>吧。</p>

  <p>什么？你还在用<code class="language-plaintext highlighter-rouge">vi</code>，来用用<code class="language-plaintext highlighter-rouge">vi</code>改进版<code class="language-plaintext highlighter-rouge">vim</code>吧。</p>

  <p>不会还有人用<code class="language-plaintext highlighter-rouge">vim</code>吧，来试试全新内核<code class="language-plaintext highlighter-rouge">nvim(neovim)</code><a href="https://github.com/neovim/neovim">neovim</a>。</p>

  <p><code class="language-plaintext highlighter-rouge">nvim</code>配置太麻烦了，来用用基本免配置的<code class="language-plaintext highlighter-rouge">lvim</code>吧。</p>

  <p><strong>vim的插件都来自github上的开源软件，建议以适当的方式访问</strong></p>
</blockquote>

<h3 id="nvim">Nvim</h3>

<h4 id="安装-4">安装</h4>

<p>对于<code class="language-plaintext highlighter-rouge">Ubuntu</code>用户，不要在<code class="language-plaintext highlighter-rouge">apt</code>中安装，版本太老，建议在<code class="language-plaintext highlighter-rouge">Github</code>上下载安装包。</p>

<p>发行版下载源和安装说明：https://github.com/neovim/neovim/releases/tag/stable</p>

<h4 id="配置-3">配置</h4>

<p>这个我还真没法教，每个人都有独特的代码习惯和审美特点。<a href="https://github.com/rockerBOO/awesome-neovim">这里</a>有全部的插件介绍，选择自己喜欢的进行配置吧。</p>

<p><a href="https://neovimcraft.com/">neovimcraft</a>集聚了优秀的插件和最新的插件，还有插件排行榜。</p>

<p>但是我还是有我自己的配置文件，并在<code class="language-plaintext highlighter-rouge">Github</code>建有仓库，名叫<code class="language-plaintext highlighter-rouge">Ynvim</code>。基本满足了我自己需求；安装方法和配置参见<a href="http://43.139.35.156/75/nvim-config/">nvim Config</a>。</p>

<p>自己配置的效果图：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20230207113218071.png" alt="image-20230207113218071" /></p>

<p><strong>但是都是一些简单的配置，具体配置方法，请在上文中的插件链接中找到对应的插件文档，阅读文档进行配置</strong>。</p>

<h3 id="lvim">Lvim</h3>

<p>不想自己配置，想直接使用现代化编辑器，<code class="language-plaintext highlighter-rouge">lvim</code>确实是一个不错的选择。</p>

<p>官网：<a href="lunarvim.org">lunarvim</a></p>

<p>官方效果图：</p>

<p><img src="https://user-images.githubusercontent.com/29136904/191624942-3d75ef87-35cf-434d-850e-3e7cd5ce2ad0.png" alt="lvim" /></p>

<h4 id="安装-5">安装</h4>

<ul>
  <li>Make sure you have installed the latest version of <a href="https://github.com/neovim/neovim/releases/latest"><code class="language-plaintext highlighter-rouge">Neovim v0.8.0+</code></a>.</li>
  <li>Have <a href="https://cli.github.com/"><code class="language-plaintext highlighter-rouge">git</code></a>, <a href="https://www.gnu.org/software/make/"><code class="language-plaintext highlighter-rouge">make</code></a>, <a href="https://pypi.org/project/pip/"><code class="language-plaintext highlighter-rouge">pip</code></a>, <a href="https://www.python.org/"><code class="language-plaintext highlighter-rouge">python</code></a> <a href="https://npmjs.com/"><code class="language-plaintext highlighter-rouge">npm</code></a>, <a href="https://nodejs.org/"><code class="language-plaintext highlighter-rouge">node</code></a> and <a href="https://www.rust-lang.org/tools/install"><code class="language-plaintext highlighter-rouge">cargo</code></a> installed on your system.</li>
  <li><a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">Resolve <code class="language-plaintext highlighter-rouge">EACCES</code> permissions when installing packages globally</a> to avoid error when installing packages with npm.</li>
  <li><a href="https://learn.microsoft.com/en-us/powershell/scripting/whats-new/migrating-from-windows-powershell-51-to-powershell-7?view=powershell-7.2"><code class="language-plaintext highlighter-rouge">PowerShell 7+</code></a> (for Windows)</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nv">LV_BRANCH</span><span class="o">=</span><span class="s1">'release-1.2/neovim-0.8'</span> bash &lt;<span class="o">(</span>curl <span class="nt">-s</span> https://raw.githubusercontent.com/lunarvim/lunarvim/fc6873809934917b470bff1b072171879899a36b/utils/installer/install.sh<span class="o">)</span>
</code></pre></div></div>

<p>安装完成后，运行<code class="language-plaintext highlighter-rouge">lvim</code>，开箱即用。</p>

<h3 id="nvchad">NvChad</h3>

<blockquote>
  <p>目前排行榜第一，但是该项目只提供了基本的<code class="language-plaintext highlighter-rouge">nvim</code>配置，更多的选项需要自己配置，所以，该项目需要有一定配置经验和水平的人使用。初学者使用该项目较为困难。</p>

  <p>建议能用<code class="language-plaintext highlighter-rouge">lvim</code>就用<code class="language-plaintext highlighter-rouge">lvim</code>。<code class="language-plaintext highlighter-rouge">lvim</code>的名气正在快速增长中。</p>
</blockquote>

<p>官网：https://nvchad.com/</p>

<p>官方效果图：</p>

<p><img src="https://nvchad.com/banner.webp" alt="NvChad banner screenshot" /></p>

<h4 id="安装-6">安装</h4>

<ul>
  <li>You should be an existing Vim user or keen to learn Neovim and NvChad (through these docs).</li>
  <li><a href="https://github.com/neovim/neovim/releases/tag/v0.8.0">Neovim 0.8.0</a>, if your distro/OS doesn’t have it then try <a href="https://github.com/MordechaiHadad/bob">neovim version manager</a>.</li>
  <li><a href="https://www.nerdfonts.com/">Use a Nerd Font</a> in your terminal emulator.</li>
  <li>Make sure to delete this folder <code class="language-plaintext highlighter-rouge">~/.local/share/nvim</code> on Linux/macOS or <code class="language-plaintext highlighter-rouge">~\AppData\Local\nvim</code> and <code class="language-plaintext highlighter-rouge">~\AppData\Local\nvim-data</code> on Windows.</li>
</ul>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> git clone https://github.com/NvChad/NvChad ~/.config/nvim <span class="nt">--depth</span> 1 <span class="o">&amp;&amp;</span> nvim
</code></pre></div></div>

<h3 id="使用他们">使用他们</h3>

<p>上述介绍的两个版本，以及我自己提供的配置，为了更好的使用他们（比如快捷方式），需要你去读读他们的<strong>文档</strong>。不然，就不如使用你原来的IDE啦。</p>

<p>如果你想学习如何使用<code class="language-plaintext highlighter-rouge">vim</code>，可以试试下面这个命令：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> nvim +Tutor
</code></pre></div></div>

<h2 id="杂项">杂项</h2>

<h3 id="linux扩展工具"><code class="language-plaintext highlighter-rouge">Linux</code>扩展工具</h3>

<h4 id="ripgrep">ripgrep</h4>

<blockquote>
  <p>grep的替代品，使用和速度上都要好于grep。</p>
</blockquote>

<p>安装：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">sudo </span>apt <span class="nb">install </span>ripgrep
</code></pre></div></div>

<h4 id="autojump">autojump</h4>

<blockquote>
  <p>一种更快的方式进行目录跳转。</p>
</blockquote>

<p>对于<code class="language-plaintext highlighter-rouge">oh-my-zsh</code>的安装方法：在<code class="language-plaintext highlighter-rouge">.zshrc</code>的插件中，添加<code class="language-plaintext highlighter-rouge">autojump</code>。</p>

<p>其他平台的安装方法：https://github.com/wting/autojump#installation</p>

<h4 id="fdfind">fdfind</h4>

<blockquote>
  <p>find的替代品，更加的好用和快捷。</p>
</blockquote>

<p>安装源：https://github.com/sharkdp/fd#installation</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">sudo </span>apt <span class="nb">install </span>fd
</code></pre></div></div>

<h3 id="lazygit">lazygit</h3>

<blockquote>
  <p>宁愿把项目简单复制好几份, 也不愿意用git来做版本控制，</p>

  <p>于是版本管理越来越混乱, 将来不得不投入更多时间。 ——出自ysyx</p>
</blockquote>

<p>但是，<code class="language-plaintext highlighter-rouge">git</code>接口是在太难用了；好在有<code class="language-plaintext highlighter-rouge">tmux</code>的<code class="language-plaintext highlighter-rouge">git</code>插件，但是还有更好用的。</p>

<p>链接：<a href="https://github.com/jesseduffield/lazygit">lazygit</a></p>

<p>效果预览：</p>

<p><img src="https://github.com/jesseduffield/lazygit/raw/assets/staging.gif" alt="lg" /></p>

<p>安装根据系统安装方法不同，请自己阅读<a href="https://github.com/jesseduffield/lazygit#installation">官网文档</a>。</p>

<h3 id="pwndbg">pwndbg</h3>

<blockquote>
  <p>原始的gdb的调试也不够人性化，试试这个</p>
</blockquote>

<p>链接：<a href="https://github.com/pwndbg/pwndbg">pwndbg</a></p>

<p>效果图：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20230206213710490.png" alt="image-20230206213710490" /></p>

<p>安装方法：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> git clone https://github.com/pwndbg/pwndbg
<span class="o">&gt;</span> <span class="nb">cd </span>pwndbg
<span class="o">&gt;</span> ./setup.sh
</code></pre></div></div>

<h3 id="mobile-ssh">mobile ssh</h3>

<blockquote>
  <p>ssh 是一个强大工具，但是存在一个小小的问题，网络一不小心断了，连接也就断了。</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">mosh</code>的想法就是解决这个问题，它采用<code class="language-plaintext highlighter-rouge">UDP</code>建立连接，即使断了，也会尝试连接。</p>

<p>链接：<a href="https://mosh.org/">mosh官网</a></p>

<p>安装方法：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="nb">sudo </span>apt <span class="nb">install </span>mosh
</code></pre></div></div>

<h3 id="nvm">nvm</h3>

<blockquote>
  <p>用于管理<code class="language-plaintext highlighter-rouge">node</code>和<code class="language-plaintext highlighter-rouge">npm</code>版本，可以使用<code class="language-plaintext highlighter-rouge">root</code>权限。</p>
</blockquote>

<p>链接：<a href="https://github.com/nvm-sh/nvm">nvm</a></p>

<p>安装方法：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> curl <span class="nt">-o-</span> https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.3/install.sh | bash
</code></pre></div></div>

<h2 id="more">More</h2>

<blockquote>
  <p>更多好用的工具需要你我的探索</p>
</blockquote>

<h3 id="终端模拟器">终端模拟器</h3>

<h4 id="windows">Windows</h4>

<p>对于<code class="language-plaintext highlighter-rouge">Windows</code>用户，我推荐<code class="language-plaintext highlighter-rouge">Tabby</code>，比较现代化。同样它提供了<code class="language-plaintext highlighter-rouge">Linux</code>和<code class="language-plaintext highlighter-rouge">Mac</code>版本。</p>

<p>链接：<a href="https://github.com/Eugeny/tabby">tabby</a></p>

<p><img src="https://github.com/Eugeny/tabby/raw/master/docs/readme.png" alt="img" /></p>

<h4 id="linux">Linux</h4>

<p>网上的推荐是<code class="language-plaintext highlighter-rouge">kitty</code>，采用了<code class="language-plaintext highlighter-rouge">GPU</code>加速，提供了更多的设置选项，包括主题。</p>

<p>优点：提供了类似tmux的多路复用操作，便捷键要比tmux友好，但是UI不如自己配置的tmux。</p>

<p>效果图：</p>

<p><img src="https://raw.githubusercontent.com/YEWPO/yewpoblogonlinePic/main/image-20230206214056682.png" alt="image-20230206214056682" /></p>

<p>链接：<a href="https://github.com/kovidgoyal/kitty">kitty</a></p>

<h2 id="学习使用工具">学习使用工具</h2>

<blockquote>
  <p>即使给你推荐再多的工具，你不知道怎么用，这不有点浪费电脑空间</p>
</blockquote>

<p>学习方法：</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">help</code>，<code class="language-plaintext highlighter-rouge">man</code>命令行工具可能有其他工具的介绍</li>
  <li>官方的手册或者是视频教程</li>
  <li>动手实践，不实际使用你就忘了</li>
  <li>遇到问题，尝试用<code class="language-plaintext highlighter-rouge">google</code>搜索一下</li>
  <li>你觉得使用比较麻烦的时候，多半有快捷操作，建议搜索一下</li>
</ul>]]></content><author><name></name></author><category term="terminal" /><summary type="html"><![CDATA[抛弃bash，享受zsh &gt;表示命令行 需要从github下载一些工具 更多好的插件遇到了尽量会在这个文档中补充]]></summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2024/02/16/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2024-02-16T13:30:02+08:00</published><updated>2024-02-16T13:30:02+08:00</updated><id>http://localhost:4000/jekyll/update/2024/02/16/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/02/16/welcome-to-jekyll.html"><![CDATA[<p>You’ll find this post in your <code class="language-plaintext highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="language-plaintext highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>Jekyll requires blog post files to be named according to the following format:</p>

<p><code class="language-plaintext highlighter-rouge">YEAR-MONTH-DAY-title.MARKUP</code></p>

<p>Where <code class="language-plaintext highlighter-rouge">YEAR</code> is a four-digit number, <code class="language-plaintext highlighter-rouge">MONTH</code> and <code class="language-plaintext highlighter-rouge">DAY</code> are both two-digit numbers, and <code class="language-plaintext highlighter-rouge">MARKUP</code> is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry></feed>